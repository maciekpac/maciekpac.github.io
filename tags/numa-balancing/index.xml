<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NUMA balancing on PMem.io</title><link>https://pmem.io/tags/numa-balancing/</link><description>Recent content in NUMA balancing on PMem.io</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 22 Jun 2022 00:00:00 +0200</lastBuildDate><atom:link href="https://pmem.io/tags/numa-balancing/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing Transparent Tiering Solution</title><link>https://pmem.io/blog/2022/06/writing-transparent-tiering-solution/</link><pubDate>Wed, 22 Jun 2022 00:00:00 +0200</pubDate><guid>https://pmem.io/blog/2022/06/writing-transparent-tiering-solution/</guid><description>This article is intended for those who would like to learn how tiering/numa balancing or memory profiling solutions work under the hood. We will focus on a high-level overview of how tiering/numa balancing could be designed, instead of dissecting any particular solution. This approach means that the readers can also learn some general knowledge on topics such as Linux API, hardware-accelerated performance monitoring or architecture of Linux apps.
Key components Before we delve into details, we will shortly discuss key requirements and map them to components of the software we want to design.</description></item></channel></rss>